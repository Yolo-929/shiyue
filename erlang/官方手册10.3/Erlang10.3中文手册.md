## 1 介绍

### 1.1 范围

Erlang运行时系统应用程序ERTS包含运行Erlang系统所需的功能。

> 注意
>
> 默认情况下，仅保证ERTS与ERTS本身相同版本中的其他Erlang / OTP组件兼容。
>
> 有关如何与早期版本中的Erlang / OTP组件进行通信的信息，请参见erl（1）中的系统标志+ R的文档。

### 1.2 前提

假定读者熟悉Erlang编程语言。

---

## 2 Erlang中的通讯


从概念上讲，Erlang中的通信是使用异步信号执行的。 所有不同的执行实体（例如进程和端口）都通过异步信号进行通信。 最常用的信号是消息。 其他常见信号是退出，链接，取消链接，监视和演示信号。

### 2.1信号传递


发送信号和信号到达目的地之间经过的时间未指定，但为正数。 如果接收器已经终止，则信号不会到达，但是会触发另一个信号。 例如，发送到不存在的进程的链接信号会触发退出信号，然后将退出信号发送回链接信号所源自的位置。当分配通讯时，如果分配通道断开，信号可能会丢失。

唯一给出的信号排序保证是：如果一个实体向同一目的实体发送多个信号，则保持该顺序；即，如果A向B发送信号S1，随后向B发送信号S2，则保证S1不会在S2之后到达。

### 2.2同步通讯

某些通信是同步的。 如果分解为多个部分，则同步通信操作将由两个异步信号组成。 一个请求信号和一个答复信号。 这种同步通信的一个示例是:当第一个参数不是`self（）`时调用`erlang：process_info / 2`。 调用方发送请求信息的异步信号，然后等待包含请求信息的回复信号。 当请求信号到达其目的地时，目的地进程将回复所请求的信息。

### 2.3实现

虚拟机中不同异步信号的实现可以随时间变化，但行为始终遵守如上所述在实体之间传递异步信号的概念。

通过检查实现，您可能会注意到某些特定的信号提供了比上面描述的更严格的保证。 非常重要的一点是，Erlang代码不使用这种关于实现的知识，因为实现可以在没有事先通知的情况下随时更改。

主要实现更改的示例：

- 从ERTS 5.5.2开始，到进程的出口信号实际上是异步传递的。

- 从ERTS 5.10开始，从进程到端口的所有信号都是真正异步传递的。

---

## 3 Erlang中的时间和时间校正

> 可参考的博客 
>
> 时间定义 https://www.cnblogs.com/me-sa/archive/2012/05/17/erlang-calendar-date-time.html
>
> Erlang时间系统 https://wudeng.github.io/2018/03/29/erlang-time/

### 3.1，新的扩展时间功能

> 注意
>
>
> 从Erlang / OTP 18（ERTS 7.0）开始，时间功能已扩展。 这包括用于时间和时间扭曲模式的新API，这些时间和时间扭曲模式会在系统时间更改时更改系统行为。
>
>
> 默认的时间扭曲模式具有与以前相同的行为，并且旧的API仍然有效。 因此，除非您愿意，否则无需更改任何内容。 但是，强烈建议您使用新的API而不是基于`erlang：now / 0`的旧API。  `erlang：now / 0`仍被弃用，它将成为可伸缩性瓶颈。
>
> 通过使用新的API，您可以自动获得可伸缩性和性能改进。 这也使您能够使用多次扭曲方式，以提高时间测量的准确性和精确度。

### 3.2术语


为了便于理解本节，定义了一些术语。 这是我们自己的术语（Erlang / OS系统时间，Erlang / OS单调时间，时间扭曲）和全球公认的术语的混合。

#### 单调增加


在值的单调递增序列中，所有具有前任的值都大于或等于其前任。

#### 严格单调增加


在严格单调递增的值序列中，所有具有前任的值都大于其前任。

#### UT1


世界时间。  UT1基于地球的自转，从概念上讲是指经度为0°的太阳时间。

#### UTC


协调世界时。  UTC几乎与UT1对齐。 但是，UTC使用秒的SI定义，该长度与UT1使用的秒的长度不完全相同。 这意味着UTC从UT1缓慢漂移。 为了使UTC与UT1保持相对同步，插入了leap秒，并可能将其删除。 也就是说，UTC日可以是86400、86401或86399秒。

#### POSIX Time


自大纪元以来的时间。 纪元定义为世界标准时间1970年1月1日00:00:00。  POSIX时间中的一天定义为正好是86400秒。 奇怪的是，大纪元被定义为UTC时间，而UTC还定义了一天的时间。 引用开放组“尽管出现POSIX时间也不一定是UTC”。 这样的效果是，当插入UTC leap秒时，POSIX时间要么停止一秒，要么重复最后一秒。 如果UTC leap秒将被删除（尚未发生），则POSIX时间将向前跳一秒。

#### 时间解析


读取时间值时可以区分的最短时间间隔。

#### Time Precision


读取时间值时可以重复可靠地区分的最短时间间隔。 精度受分辨率的限制，但是分辨率和精度可能会有很大差异。

#### Time Accuracy


时间值的正确性。

#### 时间扭曲


时间扭曲是时间向前或向后的跳跃。 即，在时间扭曲之前和之后获得的时间值的差不对应于实际经过的时间。

#### 操作系统时间


POSIX时间的操作系统视图。 要查询它，请调用`os：system_time（）`。 这可能不是POSIX时间的准确视图。 通常可以无限制地向后和向前调整该时间。 即，可以观察到时间扭曲。

>
> 要获取有关Erlang运行时系统的OS系统时间源的信息，请调用erlang：system_info（os_system_time_source）。
>

#### 操作系统单调时间


操作系统提供的单调增加的时间。 尽管不是完全正确，但此时间不会跳跃并且具有相对稳定的频率。 但是，如果系统挂起，则操作系统单调时间停止的情况并不罕见。 该时间通常会增加，因为某些未指定的时间点未连接到OS系统时间。 并非所有操作系统都必须提供这种类型的时间。

>
> 要获取有关Erlang运行时系统OS单调时间源的信息，请调用erlang：system_info（os_monotonic_time_source）。
>

#### Erlang系统时间


POSIX时间的Erlang运行时系统视图。 要检索它，请调用`erlang：system_time（）`。


此时间可能是（或）不是POSIX时间的准确视图，并且可能（也可能）与OS系统时间不一致。 运行时系统致力于使两个系统时间对齐。 根据使用的时间扭曲模式，可以通过让Erlang系统时间执行时间扭曲来实现此目的。

#### Erlang单调时间


Erlang运行时系统提供的单调增加的时间。 从某个未指定的时间点开始，Erlang单调时间增加。 要查询它，请调用`erlang：monotonic_time（）`。


Erlang单调时间的准确性和精度在很大程度上取决于以下各项：

- OS单调时间的精度和精确度

- 操作系统时间的准确性和精确度

- 使用时间扭曲模式


在没有OS单调时间的系统上，Erlang单调时间可以保证单调性，但不能提供其他保证。 对Erlang单调时间进行的频率调整取决于所使用的时间扭曲模式。


在运行时系统内部，Erlang单调时间是“时间引擎”，用于或多或少地与时间有关的所有事情。 所有计时器，无论它是在receive...after计时器，BIF计时器还是在`timer（3）`模块中的计时器，都是触发相对的Erlang单调时间。 甚至Erlang系统时间也基于Erlang单调时间。 通过将当前Erlang单调时间与当前时间偏移量相加，可以得到当前Erlang系统时间。


要获取当前时间偏移，请调用`erlang：time_offset / 0`。

### 3.3引言


时间对于Erlang程序至关重要，更重要的是，正确的时间对于Erlang程序至关重要。 由于Erlang是一种具有软实时属性的语言，并且我们可以在程序中表达时间，因此虚拟机和该语言必须谨慎选择正确的时间以及时间函数的行为。


在设计Erlang时，假定系统中的挂钟时间以与时间定义完全相同的速度显示出单调时间。 这或多或少意味着希望将原子钟（或更好的时间源）连接到您的硬件，然后再将硬件锁定为永远不会被任何人类修补。 尽管这可能是一个令人信服的想法，但事实并非如此。


除非您连接了芯片级原子钟，否则“普通”现代计算机无法保留时间，也不能保留时间。 您的计算机所感知的时间通常必须更正。 因此，网络时间协议（NTP）协议与ntpd进程一起，将尽最大努力使计算机时间与正确的时间保持同步。 在NTP校正之间，通常使用比原子钟更有效的计时器。


但是，NTP不是故障安全的。  NTP服务器可能不可用，ntp.conf可能配置错误，或者您的计算机有时可能与Internet断开连接。 此外，您可以让用户（甚至系统管理员）认为处理夏时制的正确方法是一年两次调整时钟一次（这是不正确的方法）。 更复杂的是，该用户从Internet上获取了您的软件，但并未考虑计算机认为正确的时间。 用户并不关心使挂钟与正确的时间保持同步。 用户希望您的程序对时间有无限的了解。


大多数程序员还期望时间是可靠的，至少直到他们意识到工作站上的挂钟时间减少一分钟为止。 然后他们将其设置为正确的时间，但很可能不是很顺利。


当您始终希望系统上的墙上时钟时间正确时，可能会出现很多问题。 因此，Erlang在很多年前就引入了“校正的时间估计”或“时间校正”。 时间校正依赖于以下事实：大多数操作系统都具有某种单调时钟，即实时扩展或某些独立于壁钟设置的内置“刻度计数器”。 该计数器的分辨率可以是微秒或更小，但它的漂移不容忽视。

### 3.4时间校正


如果启用了时间校正，则Erlang运行时系统将同时使用OS系统时间和OS单调时间，以调整Erlang单调时钟的频率。 时间校正可确保Erlang单调时间不会扭曲，并且频率相对准确。 频率调整的类型取决于所使用的时间扭曲模式。 部分时间扭曲模式提供了更多详细信息。


默认情况下，如果特定平台上存在对时间校正的支持，则启用时间校正。 对它的支持包括由OS提供的OS单调时间，以及在使用OS单调时间的Erlang运行时系统中的实现。 要检查您的系统是否支持OS单调时间，请调用`erlang：system_info（os_monotonic_time_source`）。 要检查系统上是否启用了时间校正，请调用`erlang：system_info（time_correction）`。


要启用或禁用时间校正，请将命令行参数`+ c [true | false]`传递给`erl（1`）。


如果禁用了时间校正，则Erlang单调时间可能会向前弯曲或停止，甚至冻结很长一段时间。 这样就不能保证Erlang单调时钟的频率准确或稳定。


通常，您永远都不想禁用时间校正。 以前，性能损失会与时间校正相关联，但如今，通常情况是相反的。 如果禁用了时间校正，则可能会导致可伸缩性，性能和时间度量不佳。

### 3.5时间扭曲安全代码


时间扭曲安全代码可以处理Erlang系统时间的时间扭曲。


当Erlang系统时间扭曲时，`erlang：now / 0`表现不佳。 当Erlang系统时间向后扭曲时，从`erlang：now / 0`返回的值将冻结（如果您忽略由于实际调用而导致的微秒增量），直到OS系统时间到达`erlang：now/0`返回的最后一个值的点为止 。 这种冻结可以持续很长时间。 冻结可能要花费数年，数十年甚至更长的时间。

`erlang：now / 0`的所有用法不一定都是时间扭曲不安全的。 如果您不使用它来获取时间，那么时间扭曲是安全的。 但是，从性能和可伸缩性的角度来看，对`erlang：now / 0`的所有使用都不理想。 因此，您真的想用其他功能代替它的使用。 有关如何替换`erlang：now / 0`的用法的示例，请参见 **[How to Work with the New API](http://xxwy.wiki/cited/otp21.3/erts-10.3/doc/html/time_correction.html#Dos_and_Donts)**.

### 3.6时间扭曲模式


当前的Erlang系统时间是通过将当前的Erlang单调时间与当前时间偏移量相加确定的。 根据使用的时间扭曲模式，对时间偏移进行不同的管理。


要设置时间扭曲模式，请将命令行参数`+ C [no_time_warp | single_time_warp | multi_time_warp]`传递给`erl（1）`。

#### 无时间扭曲模式


时间偏移是在运行系统启动时确定的，以后不会更改。 这是默认行为，但不是因为它是最佳模式（不是）。 这是默认设置，仅因为这是运行系统在ERTS 7.0之前的行为方式。 在启用其他模式之前，请确保可以在时间扭曲期间执行的Erlang代码是时间扭曲安全的。


由于不允许更改时间偏移，因此时间校正必须调整Erlang单调时钟的频率，以使Erlang系统时间与OS系统时间平滑对齐。 这种方法的主要缺点是，如果需要调整，我们将故意在Erlang单调时钟上使用错误的频率。 此错误可能高达1％。 该错误将显示在运行系统的所有时间测量中。


如果未启用时间校正，则OS系统时间向后跳跃时，Erlang单调时间将冻结。 单调时间的冻结一直持续到OS系统时间赶上。 冻结可以持续很长时间。 当OS系统时间飞跃时，Erlang单调时间也飞跃。

#### 单次扭曲模式


从引入开始，该模式或多或少是向后兼容模式。


在嵌入式系统上，系统关闭时通常没有电源，甚至没有电池。 当系统启动时，此类系统上的系统时钟通常会偏离。 如果不使用时间扭曲模式，并且在更正OS系统时间之前启动了Erlang运行时系统，则Erlang系统时间可能会长时间，数百年甚至更长的时间是错误的。


如果需要使用时间扭曲不安全的Erlang代码，并且需要在更正OS系统时间之前启动Erlang运行时系统，则可能要使用单一时间扭曲模式。

> 使用此模式可以执行时间扭曲不安全代码的时间有所限制。 如果只能使用时间扭曲安全代码，则最好使用多时间扭曲模式。

使用单次时间扭曲模式，时间偏移分为两个阶段：

##### 初步阶段


该阶段在运行系统启动时开始。 确定基于当前OS系统时间的初步时间偏移。 从现在开始，此偏移量将在整个初始阶段固定下来。


如果启用了时间校正，则将对Erlang单调时钟进行调整，以使其频率尽可能保持正确。 但是，在尝试调整Erlang系统时间和OS系统时间时，没有进行任何调整。 也就是说，在预备阶段，Erlang系统时间和OS系统时间可能会彼此偏离，因此未尝试阻止此情况。


如果禁用了时间校正，则OS系统时间的更改会像使用无时间扭曲模式时一样影响单调时钟。

##### 最后阶段


当用户通过调用`erlang：system_flag（time_offset，finalize）`最终确定时间偏移时，此阶段开始。 最终确定只能执行一次。


在完成过程中，将调整并固定时间偏移，以使当前的Erlang系统时间与当前的OS系统时间保持一致。 由于时间偏移可以在最终确定期间更改，因此Erlang系统时间可以在此时进行时间扭曲。 从现在开始，时间偏移是固定的，直到运行系统终止。 如果启用了时间校正，则从现在开始的时间校正还将进行调整，以使Erlang系统时间与OS系统时间对齐。 当系统处于最后阶段时，其行为与无时间扭曲模式下的行为完全相同。


为了使其正常工作，用户必须确保满足以下两个要求：

###### 前进时间扭曲


最终确定时间偏移时所做的时间扭曲只能向前完成，而不会遇到问题。 这意味着在启动Erlang运行时系统之前，用户必须确保OS系统时间设置为早于或等于实际POSIX时间。


如果您不确定OS系统时间是否正确，则为安全起见，请将其设置为保证在启动Erlang运行时系统之前早于实际POSIX时间的时间。

###### 敲定正确的操作系统时间


用户确定时间偏移时，操作系统时间必须正确。


如果不满足这些要求，则系统可能会表现很差。

假设满足了这些要求，启用了时间校正，并使用诸如NTP之类的时间调整协议来调整OS系统时间，则只需对Erlang单调时间进行少量调整即可使系统时间在最终确定后保持一致。 只要系统未挂起，所需的最大调整就是插入（或删除）leap秒。

> 要使用此模式，请确保将在两个阶段执行的所有Erlang代码都是时间扭曲安全的。 
>
>  仅在最后阶段执行的代码不必能够处理时间偏差。

#### 多时间扭曲模式。 

 结合时间校正的多时间翘曲模式是首选配置。 这是因为Erlang运行时系统在几乎所有平台上都有更好的性能、更好的伸缩性和更好的行为。 此外，时间测量的准确度和精确度也更好。 只有在旧平台上执行的Erlang运行时系统才能从另一种配置中受益。 

 时间偏移量可以不受限制地随时更改。 也就是说，Erlang系统时间可以随时向前和向后执行时间扭曲。 当我们通过更改时间偏移量将Erlang系统时间与OS系统时间对齐时，我们可以启用时间校正，试图将Erlang单调时钟的频率调整为尽可能准确。 这使得使用Erlang单调时间的时间测量更加准确和精确。 

 如果禁用时间校正，则如果操作系统时间向前跳跃，则Erlang单调时间向前跳跃。 如果操作系统时间倒退，Erlang单调时间会短暂停止，但不会在较长时间内冻结。 这是因为更改了时间偏移量，以使Erlang系统时间与OS系统时间保持一致。